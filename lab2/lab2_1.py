# -*- coding: utf-8 -*-
"""lab2.1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lZTnvh0HKGdQkGEYKIfbw0HM9gFl9_Ww

Подключение библиотек
"""

import numpy as np
from PIL import Image, ImageOps
import os
import matplotlib.pyplot as plt
from google.colab import drive 
drive.mount('/content/drive')
!ls "/content/drive/My Drive/"

"""Объявление всех необходимых переменных"""

l = 0.1 #learning spead
leftTracksPath = "/content/drive/My Drive/NeuronLabs/LeftTracks"
rightTracksPath = "/content/drive/My Drive/NeuronLabs/RightTracks"
leftTestTracksPath = "/content/drive/My Drive/NeuronLabs/LeftTestTracks"
rightTestTracksPath = "/content/drive/My Drive/NeuronLabs/RightTestTracks"
t_x = []
t_y = []
test_x = []
test_y = []

"""Необходимые классы"""

class Neuron:
  def __init__(self, weights):
    self.weights = weights
    self.bias = 1
    self.biasWeight = 1
    self.sum = 0

  def getAnswer(self, inputs):
    answer = np.dot(self.weights, inputs) + self.bias * self.biasWeight
    self.sum = answer
    return func_act(answer)

  def fit(self, x, answer, expected):
    for i in range(len(self.weights)):
      self.weights[i] = func_delta_rule(x[i], expected, answer, self.sum, self.weights[i])
    self.biasWeight = func_delta_rule(self.bias, expected, answer, self.sum, self.biasWeight)

class NeuronNetwork:
  def __init__(self, layerNeurons, inputCount):
    self.layerNeurons = layerNeurons
    self.layerCount = len(layerNeurons)
    self.inputCount = inputCount
    self.neuronCount = sum(layerNeurons)
    self.neurons = []
    self.losses = []
    self.epochs = []

  def fill_random_weights(self):
    inputs = self.inputCount
    for i in range(len(self.layerNeurons)):
      layer = []
      print(self.layerNeurons[i])
      for j in range(self.layerNeurons[i]):
        w = np.random.randint(-20,20, inputs)/3
        layer.append(Neuron(w))
      self.neurons.append(layer)
      inputs = self.layerNeurons[i]

  def predict(self, x_i):
    answers = []
    inputs = x_i
    for i in range(len(self.layerNeurons)):
      layerAnswers = []
      for j in range(self.layerNeurons[i]):
        layerAnswers.append(self.neurons[i][j].getAnswer(inputs))
      inputs = layerAnswers
      answers.append(layerAnswers)
    return answers[len(answers)-1][0]

  def loss(self, x,y):
    loss = 0
    for j in range(len(x)):
      answer = self.predict(x[j])
      loss += np.square(y[j] - answer)
    return loss/ len(x)

  def fit(self, inputs, expected, e):
    epoch = 1
    self.epochs.append(epoch)
    loss = self.loss(inputs, expected)
    self.losses.append(loss)
    while loss > e and epoch < 25000:
      if(epoch % 1000 == 0):
        print(epoch, "epoch has started.. Error:", self.loss(inputs, expected))
      #for i in range(len(inputs)):
      i = np.random.randint(0, len(inputs))
      l_inp = inputs[i]
      answer = self.predict(inputs[i])
      if np.abs(answer - expected[i]) > e: 
        for j in range(self.layerCount-1):
          l_answ = []
          for k in range(len(self.neurons[j])):
            l_answ.append(self.neurons[j][k].getAnswer(l_inp))
            self.neurons[j][k].fit(l_inp, answer, expected[i])
          l_inp = l_answ
        loss = self.loss(inputs, expected)
        self.losses.append(loss)
        epoch += 1
        self.epochs.append(epoch)
    print("network was learned for",epoch,"generations")

"""Вспомагательные функции"""

def func_act(value):
  return 1 / (1 + np.exp(-value))

def pr_func_act(value):
  return func_act(value) * (1 - func_act(value))

def func_delta_rule(x, exp_y, act_y, sum, w):
  return w - l * (exp_y - act_y) * pr_func_act(sum) * x
  #return w + l * x * exp_y

def AddVehicle(path):
  test_img = Image.open(path)
  test_img = test_img.resize((5,5))
  test_img = test_img.convert('L')
  #plt.imshow(test_img, cmap = 'gray')
  #plt.show()

  test_x = np.array(test_img, np.float32)
  test_x = test_x.reshape(-1,25)
  test_x = test_x / 255
  return test_x[0]

def AddLeftTrucks():
  for filename in os.listdir(leftTracksPath):
    path = os.path.join(leftTracksPath, filename)
    t_x.append(AddVehicle(path))
    t_y.append(0)

def AddRightTrucks():
  for filename in os.listdir(rightTracksPath):
    path = os.path.join(rightTracksPath, filename)
    t_x.append(AddVehicle(path))
    t_y.append(1)

def AddTestTrucks():
  for filename in os.listdir(leftTestTracksPath):
    path = os.path.join(leftTestTracksPath, filename)
    test_x.append(AddVehicle(path))
    test_y.append(0)
  for filename in os.listdir(rightTestTracksPath):
    path = os.path.join(rightTestTracksPath, filename)
    test_x.append(AddVehicle(path))
    test_y.append(1)

def output_weights(neuronNetwork : NeuronNetwork):
  for i in range(neuronNetwork.layerCount):
    for j in range(len(neuronNetwork.neurons[i])):
      print(str(i) + " " + str(j) + " " + str(len(neuronNetwork.neurons[i][j].weights)))# + str(neuronNetwork.neurons[i][j].weights))

"""Заполнение начальных данных"""

AddLeftTrucks()
AddRightTrucks()
AddTestTrucks()

"""Начальные веса"""

neuronNetwork = NeuronNetwork([10, 8, 6, 1], 25)
neuronNetwork.fill_random_weights()

"""Веса после обучения"""

neuronNetwork.fit(t_x, t_y, 0.01)

for i in range(len(test_y)):
  print(neuronNetwork.predict(test_x[i]), ": ", test_y[i])

plt.plot(neuronNetwork.epochs, neuronNetwork.losses)
plt.show()